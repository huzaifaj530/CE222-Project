$date
	Sun May 14 19:07:33 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$var wire 32 ! instr [31:0] $end
$var wire 10 " pc_out [9:0] $end
$var reg 1 # clk $end
$var reg 1 $ reset $end
$scope module uut $end
$var wire 3 % alu_op [2:0] $end
$var wire 1 & alu_src $end
$var wire 1 ' branch $end
$var wire 1 ( clk $end
$var wire 32 ) data_out [31:0] $end
$var wire 3 * func3 [2:0] $end
$var wire 7 + func7 [6:0] $end
$var wire 21 , imm [20:0] $end
$var wire 32 - instr [31:0] $end
$var wire 32 . instruction [31:0] $end
$var wire 1 / mem_read $end
$var wire 2 0 mem_to_reg [1:0] $end
$var wire 1 1 mem_write $end
$var wire 7 2 opcode [6:0] $end
$var wire 32 3 out1 [31:0] $end
$var wire 32 4 out2 [31:0] $end
$var wire 10 5 pc [9:0] $end
$var wire 10 6 pc_out [9:0] $end
$var wire 5 7 r1 [4:0] $end
$var wire 5 8 r2 [4:0] $end
$var wire 5 9 rd [4:0] $end
$var wire 1 : reg_write $end
$var wire 1 ; reset $end
$var wire 32 < result [31:0] $end
$var wire 1 = size $end
$var wire 32 > write_data [31:0] $end
$var wire 1 ? zero_flag $end
$scope module PC1 $end
$var wire 1 ' branch $end
$var wire 1 ( clk $end
$var wire 2 @ mem_to_reg [1:0] $end
$var wire 21 A offset [20:0] $end
$var wire 32 B reg_out1 [31:0] $end
$var wire 1 ; reset $end
$var wire 1 ? zero_flag $end
$var reg 10 C count [9:0] $end
$upscope $end
$scope module INSTRUCTION_MEMORY $end
$var wire 1 ( clk $end
$var wire 10 D read_addr [9:0] $end
$var reg 32 E instruction [31:0] $end
$upscope $end
$scope module DECODER $end
$var wire 1 ( clk $end
$var wire 32 F instruction [31:0] $end
$var reg 3 G func3 [2:0] $end
$var reg 7 H func7 [6:0] $end
$var reg 21 I imm [20:0] $end
$var reg 7 J opcode [6:0] $end
$var reg 5 K r1 [4:0] $end
$var reg 5 L r2 [4:0] $end
$var reg 5 M rd [4:0] $end
$var reg 1 N size $end
$upscope $end
$scope module CONTROL $end
$var wire 1 ( clk $end
$var wire 7 O opcode [6:0] $end
$var reg 3 P alu_op [2:0] $end
$var reg 1 Q alu_src $end
$var reg 1 R branch $end
$var reg 1 S mem_read $end
$var reg 2 T mem_to_reg [1:0] $end
$var reg 1 U mem_write $end
$var reg 1 V reg_write $end
$upscope $end
$scope module ALU_C $end
$var wire 1 ( clk $end
$var wire 3 W func3 [2:0] $end
$var wire 7 X func7 [6:0] $end
$var wire 7 Y opcode [6:0] $end
$var reg 3 Z alu_control [2:0] $end
$upscope $end
$scope module REG_FILE $end
$var wire 1 ( clk $end
$var wire 5 [ r1 [4:0] $end
$var wire 5 \ r2 [4:0] $end
$var wire 5 ] rd [4:0] $end
$var wire 1 : wr $end
$var wire 32 ^ write_data [31:0] $end
$var reg 32 _ out1 [31:0] $end
$var reg 32 ` out2 [31:0] $end
$upscope $end
$scope module ALU_MUX $end
$var wire 1 & alu_src $end
$var wire 1 ( clk $end
$var wire 21 a imm [20:0] $end
$var wire 32 b reg2 [31:0] $end
$var reg 32 c out [31:0] $end
$upscope $end
$scope module ALU $end
$var wire 32 d a [31:0] $end
$var wire 3 e alu_control [2:0] $end
$var wire 32 f b [31:0] $end
$var wire 1 ( clk $end
$var reg 32 g out [31:0] $end
$var reg 1 h zero_flag $end
$upscope $end
$scope module DATA_MEMORY $end
$var wire 32 i address [31:0] $end
$var wire 1 ( clk $end
$var wire 1 / mem_rd $end
$var wire 1 1 mem_wr $end
$var wire 1 = size $end
$var wire 32 j write_data [31:0] $end
$var reg 32 k read_data [31:0] $end
$upscope $end
$scope module MEM_MUX $end
$var wire 32 l alu_result [31:0] $end
$var wire 1 ( clk $end
$var wire 32 m mem_data [31:0] $end
$var wire 2 n mem_to_reg [1:0] $end
$var wire 10 o pc [9:0] $end
$var reg 32 p out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx p
b0 o
bx n
bx m
bx l
bx k
bx j
bx i
xh
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
xV
xU
bx T
xS
xR
xQ
bx P
bx O
xN
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
b0 D
b0 C
bx B
bx A
bx @
x?
bx >
x=
bx <
1;
x:
bx 9
bx 8
bx 7
b0 6
b0 5
bx 4
bx 3
bx 2
x1
bx 0
x/
bx .
bx -
bx ,
bx +
bx *
bx )
0(
x'
x&
bx %
1$
0#
b0 "
bx !
$end
#1000
b100010000000010110011 E
b100010000000010110011 .
b100010000000010110011 F
b100010000000010110011 !
b100010000000010110011 -
1N
1=
b0 M
b0 9
b0 ]
b0 L
b0 8
b0 \
b0 K
b0 7
b0 [
b0 I
b0 ,
b0 A
b0 a
b0 H
b0 +
b0 X
b0 G
b0 *
b0 W
0h
0?
1#
1(
#2000
b1 C
b1 5
b1 D
b1 o
b1 "
b1 6
0#
0(
0$
0;
#3000
b10 P
b10 %
b10 e
0R
0'
0U
01
0S
0/
1V
1:
b0 T
b0 0
b0 @
b0 n
0Q
0&
bx k
b10 Z
b1 L
b1 8
b1 \
b10 K
b10 7
b10 [
b10 M
b10 9
b10 ]
b110011 J
b110011 2
b110011 O
b110011 Y
b100010000000100110011 E
b100010000000100110011 .
b100010000000100110011 F
b100010000000100110011 !
b100010000000100110011 -
1#
1(
#4000
b10 C
b10 5
b10 D
b10 o
b10 "
b10 6
0#
0(
#5000
b100010000000110110011 E
b100010000000110110011 .
b100010000000110110011 F
b100010000000110110011 !
b100010000000110110011 -
b10 M
b10 9
b10 ]
b1 L
b1 8
b1 \
b10 K
b10 7
b10 [
bx k
1#
1(
#6000
b11 C
b11 5
b11 D
b11 o
b11 "
b11 6
0#
0(
#7000
bx k
b0 Z
b0x0 %
b0x0 e
b111 G
b111 *
b111 W
b100 M
b100 9
b100 ]
b1 L
b1 8
b1 \
b10 K
b10 7
b10 [
b100010111001000110011 E
b100010111001000110011 .
b100010111001000110011 F
b100010111001000110011 !
b100010111001000110011 -
1#
1(
#8000
b100 C
b100 5
b100 D
b100 o
b100 "
b100 6
0#
0(
#9000
bx E
bx .
bx F
bx !
bx -
b100 M
b100 9
b100 ]
b1 L
b1 8
b1 \
b10 K
b10 7
b10 [
b111 G
b111 *
b111 W
bx k
1#
1(
#10000
b101 C
b101 5
b101 D
b101 o
b101 "
b101 6
0#
0(
#11000
bx k
bx J
bx 2
bx O
bx Y
b0 M
b0 9
b0 ]
b0 L
b0 8
b0 \
b0 K
b0 7
b0 [
b0 G
b0 *
b0 W
1#
1(
#12000
b110 C
b110 5
b110 D
b110 o
b110 "
b110 6
0#
0(
#13000
bx k
1#
1(
#14000
b111 C
b111 5
b111 D
b111 o
b111 "
b111 6
0#
0(
#15000
bx k
1#
1(
#16000
b1000 C
b1000 5
b1000 D
b1000 o
b1000 "
b1000 6
0#
0(
#17000
bx k
1#
1(
#18000
b1001 C
b1001 5
b1001 D
b1001 o
b1001 "
b1001 6
0#
0(
#19000
bx k
1#
1(
#20000
b1010 C
b1010 5
b1010 D
b1010 o
b1010 "
b1010 6
0#
0(
#21000
bx k
1#
1(
#22000
b1011 C
b1011 5
b1011 D
b1011 o
b1011 "
b1011 6
0#
0(
